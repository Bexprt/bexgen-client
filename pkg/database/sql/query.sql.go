// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countDocumentsByStepAndState = `-- name: CountDocumentsByStepAndState :many

SELECT
    step_name,
    state,
    COUNT(*) as total
FROM document_status
GROUP BY step_name, state
`

type CountDocumentsByStepAndStateRow struct {
	StepName string          `json:"step_name"`
	State    ProcessingState `json:"state"`
	Total    int64           `json:"total"`
}

// =====================================
// DASHBOARD / MONITORING
// =====================================
func (q *Queries) CountDocumentsByStepAndState(ctx context.Context) ([]CountDocumentsByStepAndStateRow, error) {
	rows, err := q.db.Query(ctx, countDocumentsByStepAndState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountDocumentsByStepAndStateRow
	for rows.Next() {
		var i CountDocumentsByStepAndStateRow
		if err := rows.Scan(&i.StepName, &i.State, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countFailedMessagesByState = `-- name: CountFailedMessagesByState :many
SELECT
    retry_state,
    COUNT(*) as total
FROM failed_messages
GROUP BY retry_state
`

type CountFailedMessagesByStateRow struct {
	RetryState NullRetryState `json:"retry_state"`
	Total      int64          `json:"total"`
}

func (q *Queries) CountFailedMessagesByState(ctx context.Context) ([]CountFailedMessagesByStateRow, error) {
	rows, err := q.db.Query(ctx, countFailedMessagesByState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountFailedMessagesByStateRow
	for rows.Next() {
		var i CountFailedMessagesByStateRow
		if err := rows.Scan(&i.RetryState, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createDocument = `-- name: CreateDocument :one

INSERT INTO documents (
    id,
    filename,
    filepath,
    classification
)
VALUES ($1, $2, $3, $4)
RETURNING id, filename, filepath, classification, created_at, updated_at
`

type CreateDocumentParams struct {
	ID             pgtype.UUID `json:"id"`
	Filename       pgtype.Text `json:"filename"`
	Filepath       pgtype.Text `json:"filepath"`
	Classification pgtype.Text `json:"classification"`
}

// =====================================
// DOCUMENTS
// =====================================
func (q *Queries) CreateDocument(ctx context.Context, arg CreateDocumentParams) (Document, error) {
	row := q.db.QueryRow(ctx, createDocument,
		arg.ID,
		arg.Filename,
		arg.Filepath,
		arg.Classification,
	)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Filepath,
		&i.Classification,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProcessingStep = `-- name: CreateProcessingStep :exec

INSERT INTO processing_steps (
    name,
    description
)
VALUES ($1, $2)
ON CONFLICT (name) DO NOTHING
`

type CreateProcessingStepParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

// =====================================
// PROCESSING STEPS
// =====================================
func (q *Queries) CreateProcessingStep(ctx context.Context, arg CreateProcessingStepParams) error {
	_, err := q.db.Exec(ctx, createProcessingStep, arg.Name, arg.Description)
	return err
}

const ensureProcessingStep = `-- name: EnsureProcessingStep :exec
INSERT INTO processing_steps (name)
VALUES ($1)
ON CONFLICT (name) DO NOTHING
`

func (q *Queries) EnsureProcessingStep(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, ensureProcessingStep, name)
	return err
}

const getDocumentByID = `-- name: GetDocumentByID :one
SELECT id, filename, filepath, classification, created_at, updated_at
FROM documents
WHERE id = $1
`

func (q *Queries) GetDocumentByID(ctx context.Context, id pgtype.UUID) (Document, error) {
	row := q.db.QueryRow(ctx, getDocumentByID, id)
	var i Document
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Filepath,
		&i.Classification,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDocumentStatuses = `-- name: GetDocumentStatuses :many
SELECT document_id, step_name, state, message, updated_at
FROM document_status
WHERE document_id = $1
ORDER BY updated_at DESC
`

func (q *Queries) GetDocumentStatuses(ctx context.Context, documentID pgtype.UUID) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getDocumentStatuses, documentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.DocumentID,
			&i.StepName,
			&i.State,
			&i.Message,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDocumentsByStepAndState = `-- name: GetDocumentsByStepAndState :many
SELECT document_id, step_name, state, message, updated_at
FROM document_status
WHERE step_name = $1
AND state = $2
ORDER BY updated_at DESC
LIMIT $3 OFFSET $4
`

type GetDocumentsByStepAndStateParams struct {
	StepName string          `json:"step_name"`
	State    ProcessingState `json:"state"`
	Limit    int32           `json:"limit"`
	Offset   int32           `json:"offset"`
}

func (q *Queries) GetDocumentsByStepAndState(ctx context.Context, arg GetDocumentsByStepAndStateParams) ([]DocumentStatus, error) {
	rows, err := q.db.Query(ctx, getDocumentsByStepAndState,
		arg.StepName,
		arg.State,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DocumentStatus
	for rows.Next() {
		var i DocumentStatus
		if err := rows.Scan(
			&i.DocumentID,
			&i.StepName,
			&i.State,
			&i.Message,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFailedMessages = `-- name: GetPendingFailedMessages :many
SELECT id, document_id, topic_name, protobuf_payload, headers, error_message, retry_count, retry_state, created_at, last_retry_at
FROM failed_messages
WHERE retry_state = 'pending'
ORDER BY created_at
LIMIT $1
`

func (q *Queries) GetPendingFailedMessages(ctx context.Context, limit int32) ([]FailedMessage, error) {
	rows, err := q.db.Query(ctx, getPendingFailedMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FailedMessage
	for rows.Next() {
		var i FailedMessage
		if err := rows.Scan(
			&i.ID,
			&i.DocumentID,
			&i.TopicName,
			&i.ProtobufPayload,
			&i.Headers,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.RetryState,
			&i.CreatedAt,
			&i.LastRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessingStep = `-- name: GetProcessingStep :one
SELECT name, description, created_at
FROM processing_steps
WHERE name = $1
`

func (q *Queries) GetProcessingStep(ctx context.Context, name string) (ProcessingStep, error) {
	row := q.db.QueryRow(ctx, getProcessingStep, name)
	var i ProcessingStep
	err := row.Scan(&i.Name, &i.Description, &i.CreatedAt)
	return i, err
}

const incrementRetryCount = `-- name: IncrementRetryCount :exec
UPDATE failed_messages
SET
    retry_count = retry_count + 1,
    last_retry_at = now()
WHERE id = $1
`

func (q *Queries) IncrementRetryCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementRetryCount, id)
	return err
}

const insertFailedMessage = `-- name: InsertFailedMessage :one

INSERT INTO failed_messages (
    document_id,
    topic_name,
    protobuf_payload,
    headers,
    error_message
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, document_id, topic_name, protobuf_payload, headers, error_message, retry_count, retry_state, created_at, last_retry_at
`

type InsertFailedMessageParams struct {
	DocumentID      pgtype.UUID `json:"document_id"`
	TopicName       string      `json:"topic_name"`
	ProtobufPayload []byte      `json:"protobuf_payload"`
	Headers         []byte      `json:"headers"`
	ErrorMessage    pgtype.Text `json:"error_message"`
}

// =====================================
// FAILED MESSAGE STORAGE
// =====================================
func (q *Queries) InsertFailedMessage(ctx context.Context, arg InsertFailedMessageParams) (FailedMessage, error) {
	row := q.db.QueryRow(ctx, insertFailedMessage,
		arg.DocumentID,
		arg.TopicName,
		arg.ProtobufPayload,
		arg.Headers,
		arg.ErrorMessage,
	)
	var i FailedMessage
	err := row.Scan(
		&i.ID,
		&i.DocumentID,
		&i.TopicName,
		&i.ProtobufPayload,
		&i.Headers,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.RetryState,
		&i.CreatedAt,
		&i.LastRetryAt,
	)
	return i, err
}

const markFailedMessageDeadLetter = `-- name: MarkFailedMessageDeadLetter :exec
UPDATE failed_messages
SET
    retry_state = 'dead_letter',
    last_retry_at = now()
WHERE id = $1
`

func (q *Queries) MarkFailedMessageDeadLetter(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markFailedMessageDeadLetter, id)
	return err
}

const markFailedMessageRetried = `-- name: MarkFailedMessageRetried :exec
UPDATE failed_messages
SET
    retry_state = 'retried',
    retry_count = retry_count + 1,
    last_retry_at = now()
WHERE id = $1
`

func (q *Queries) MarkFailedMessageRetried(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markFailedMessageRetried, id)
	return err
}

const updateDocumentStatus = `-- name: UpdateDocumentStatus :exec
UPDATE document_status
SET
    state = $3,
    message = $4,
    updated_at = now()
WHERE document_id = $1
AND step_name = $2
`

type UpdateDocumentStatusParams struct {
	DocumentID pgtype.UUID     `json:"document_id"`
	StepName   string          `json:"step_name"`
	State      ProcessingState `json:"state"`
	Message    pgtype.Text     `json:"message"`
}

func (q *Queries) UpdateDocumentStatus(ctx context.Context, arg UpdateDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, updateDocumentStatus,
		arg.DocumentID,
		arg.StepName,
		arg.State,
		arg.Message,
	)
	return err
}

const upsertDocumentStatus = `-- name: UpsertDocumentStatus :exec

INSERT INTO document_status (
    document_id,
    step_name,
    state,
    message
)
VALUES ($1, $2, $3, $4)
ON CONFLICT (document_id, step_name)
DO UPDATE SET
    state = EXCLUDED.state,
    message = EXCLUDED.message,
    updated_at = now()
`

type UpsertDocumentStatusParams struct {
	DocumentID pgtype.UUID     `json:"document_id"`
	StepName   string          `json:"step_name"`
	State      ProcessingState `json:"state"`
	Message    pgtype.Text     `json:"message"`
}

// =====================================
// DOCUMENT STATUS
// =====================================
// Upsert current step status
func (q *Queries) UpsertDocumentStatus(ctx context.Context, arg UpsertDocumentStatusParams) error {
	_, err := q.db.Exec(ctx, upsertDocumentStatus,
		arg.DocumentID,
		arg.StepName,
		arg.State,
		arg.Message,
	)
	return err
}
